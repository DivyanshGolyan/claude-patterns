"""User message extraction from Claude Code JSONL files.

This module provides functionality to extract user messages from Claude Code
conversation history files.
"""

import json
import sys
import re
from pathlib import Path
from typing import List, Dict, Any

from claude_patterns.prompts import get_prompt_signature


def extract_message_content(message_data: Dict[str, Any]) -> str:
    """Extract text content from message structure."""
    content = message_data.get("content", "")

    if isinstance(content, str):
        return content
    elif isinstance(content, list):
        # Handle array of content blocks
        text_parts = []
        for block in content:
            if isinstance(block, dict):
                if block.get("type") == "text":
                    text_parts.append(block.get("text", ""))
                elif block.get("type") == "tool_use":
                    text_parts.append(f"[TOOL: {block.get('name', 'unknown')}]")
            elif isinstance(block, str):
                text_parts.append(block)
        return " ".join(text_parts)

    return ""


def is_system_generated(message: str) -> bool:
    """Check if message is system-generated (not manually typed by user)."""
    # Strip whitespace for checking
    msg = message.strip()

    # System interruptions
    if msg.startswith("[Request interrupted"):
        return True

    # Bash commands/output and local commands
    # Matches: <bash-input>, <local-command-stdout>, <bash-output>, etc.
    if re.search(r"<(?:bash|local)-(?:[\w-]+)>", msg):
        return True

    # Slash commands
    if "<command-message>" in msg and "<command-name>" in msg:
        return True

    # System caveats
    if msg.startswith("Caveat: The messages below were generated by the user"):
        return True

    # Session continuation messages
    if "This session is being continued from a previous conversation" in msg:
        return True

    # Agent warmup messages (common system message)
    if msg == "Warmup":
        return True

    # Empty or very short messages that might be artifacts
    if len(msg) < 3:  # noqa: PLR2004
        return True

    # Agent system prompts (check if the template signature appears)
    # Extract the longest static chunk from the template dynamically
    signature = get_prompt_signature()

    # If this signature appears in the message, it's the agent prompt
    if signature in msg:
        return True

    # Also filter tool results (appear as user messages in some cases)
    if '"tool_use_id"' in msg and '"type": "tool_result"' in msg:
        return True

    return False


def extract_user_messages(
    jsonl_file: Path, exclude_system: bool = False
) -> List[Dict[str, Any]]:
    """Extract all user messages from a single JSONL file."""
    user_messages = []

    try:
        with open(jsonl_file, "r", encoding="utf-8") as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                if not line:
                    continue

                try:
                    entry = json.loads(line)

                    # Skip non-user messages and summaries
                    if entry.get("type") == "summary":
                        continue

                    message = entry.get("message", {})
                    if message.get("role") != "user":
                        continue

                    # Filter slash commands (isMeta: true)
                    if exclude_system and entry.get("isMeta") is True:
                        continue

                    # Extract user message
                    content = extract_message_content(message)
                    if not content.strip():
                        continue

                    # Filter system-generated messages if requested
                    if exclude_system and is_system_generated(content):
                        continue

                    user_messages.append(
                        {
                            "message": content,
                            "uuid": entry.get("uuid", ""),
                            "timestamp": entry.get("timestamp", ""),
                            "session_id": entry.get("sessionId", ""),
                            "git_branch": entry.get("gitBranch", ""),
                            "source_file": str(jsonl_file.name),
                        }
                    )

                except json.JSONDecodeError as e:
                    print(
                        f"Warning: Skipping invalid JSON at {jsonl_file.name}:{line_num}: {e}",
                        file=sys.stderr,
                    )
                    continue

    except Exception as e:
        print(f"Error reading {jsonl_file}: {e}", file=sys.stderr)

    return user_messages


def extract_all_messages(
    folder_path: Path, exclude_system: bool = False, verbose: bool = True
) -> List[Dict[str, Any]]:
    """Extract messages from all JSONL files in a folder.

    Args:
        folder_path: Directory containing JSONL conversation files
        exclude_system: If True, filter out system-generated messages
        verbose: If True, print progress information

    Returns:
        List of extracted message dictionaries
    """
    if not folder_path.exists():
        print(f"Error: Folder '{folder_path}' does not exist", file=sys.stderr)
        sys.exit(1)

    if not folder_path.is_dir():
        print(f"Error: '{folder_path}' is not a directory", file=sys.stderr)
        sys.exit(1)

    # Find all JSONL files
    jsonl_files = sorted(folder_path.glob("*.jsonl"))

    if not jsonl_files:
        print(f"Warning: No JSONL files found in {folder_path}", file=sys.stderr)
        sys.exit(1)

    if verbose:
        print(f"Found {len(jsonl_files)} JSONL files")
        if exclude_system:
            print(
                "Filtering out system-generated messages (interruptions, bash, slash commands)"
            )

    # Extract messages from all files
    all_messages = []
    for jsonl_file in jsonl_files:
        messages = extract_user_messages(jsonl_file, exclude_system=exclude_system)
        all_messages.extend(messages)
        if verbose and messages:
            print(f"  {jsonl_file.name}: {len(messages)} user messages")

    if verbose:
        filter_msg = " (filtered)" if exclude_system else ""
        print(f"\nExtracted {len(all_messages)} user messages{filter_msg}")

        # Show some stats
        unique_sessions = len(
            set(m["session_id"] for m in all_messages if m["session_id"])
        )
        print(f"  Unique sessions: {unique_sessions}")

        if all_messages:
            avg_length = sum(len(m["message"]) for m in all_messages) / len(
                all_messages
            )
            print(f"  Average message length: {avg_length:.1f} characters")

    return all_messages


def main():
    """CLI entry point for message extraction."""
    # Parse arguments
    args = sys.argv[1:]
    if not args:
        print(
            "Usage: extract-claude-messages <folder_path> [output.json] [--exclude-system]",
            file=sys.stderr,
        )
        sys.exit(1)

    # Check for --exclude-system flag
    exclude_system = "--exclude-system" in args
    if exclude_system:
        args.remove("--exclude-system")

    folder_path = Path(args[0])
    output_file = Path(args[1]) if len(args) > 1 else Path("user_messages.json")

    # Extract messages using the shared function
    all_messages = extract_all_messages(folder_path, exclude_system, verbose=True)

    # Write to output file
    with open(output_file, "w", encoding="utf-8") as f:
        json.dump(all_messages, f, indent=2, ensure_ascii=False)

    print(f"Saved to {output_file}")

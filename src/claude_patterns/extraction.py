"""
Extraction pipeline for Claude Code conversations.

Handles multi-format content blocks (text/tool_use) and filters out
system-generated messages (bash output, interrupts, slash commands).
"""

import json
import sys
import re
from pathlib import Path
from typing import List, Dict, Any

from claude_patterns.prompts import get_prompt_signature


def validate_directory(path: Path, name: str = "Directory") -> None:
    """Ensure path exists and is a directory."""
    if not path.exists():
        print(f"Error: {name} '{path}' does not exist", file=sys.stderr)
        sys.exit(1)
    if not path.is_dir():
        print(f"Error: '{path}' is not a directory", file=sys.stderr)
        sys.exit(1)


def extract_message_content(message_data: Dict[str, Any]) -> str:
    content = message_data.get("content", "")

    if isinstance(content, str):
        return content
    elif isinstance(content, list):
        text_parts = []
        for block in content:
            if isinstance(block, dict):
                if block.get("type") == "text":
                    text_parts.append(block.get("text", ""))
                elif block.get("type") == "tool_use":
                    text_parts.append(f"[TOOL: {block.get('name', 'unknown')}]")
            elif isinstance(block, str):
                text_parts.append(block)
        return " ".join(text_parts)

    return ""


def is_system_generated(message: str) -> bool:
    """Check if message is system-generated (not manually typed by user)."""
    msg = message.strip()

    if msg.startswith("[Request interrupted"):
        return True

    if re.search(r"<(?:bash|local)-(?:[\w-]+)>", msg):
        return True

    if "<command-message>" in msg and "<command-name>" in msg:
        return True

    if msg.startswith("Caveat: The messages below were generated by the user"):
        return True

    if "This session is being continued from a previous conversation" in msg:
        return True

    if msg == "Warmup":
        return True

    if len(msg) < 3:  # noqa: PLR2004
        return True

    signature = get_prompt_signature()
    if signature in msg:
        return True

    if '"tool_use_id"' in msg and '"type": "tool_result"' in msg:
        return True

    return False


def extract_user_messages(
    jsonl_file: Path, exclude_system: bool = False
) -> List[Dict[str, Any]]:
    user_messages = []

    try:
        with open(jsonl_file, "r", encoding="utf-8") as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                if not line:
                    continue

                try:
                    entry = json.loads(line)

                    if entry.get("type") == "summary":
                        continue

                    message = entry.get("message", {})
                    if message.get("role") != "user":
                        continue

                    if exclude_system and entry.get("isMeta") is True:
                        continue

                    content = extract_message_content(message)
                    if not content.strip():
                        continue

                    if exclude_system and is_system_generated(content):
                        continue

                    user_messages.append(
                        {
                            "message": content,
                            "uuid": entry.get("uuid", ""),
                            "timestamp": entry.get("timestamp", ""),
                            "session_id": entry.get("sessionId", ""),
                            "git_branch": entry.get("gitBranch", ""),
                            "source_file": str(jsonl_file.name),
                        }
                    )

                except json.JSONDecodeError as e:
                    print(
                        f"Warning: Skipping invalid JSON at {jsonl_file.name}:{line_num}: {e}",
                        file=sys.stderr,
                    )
                    continue

    except Exception as e:
        print(f"Error reading {jsonl_file}: {e}", file=sys.stderr)

    return user_messages


def extract_all_messages(
    folder_path: Path, exclude_system: bool = False, verbose: bool = True
) -> List[Dict[str, Any]]:
    validate_directory(folder_path, "Conversations folder")

    jsonl_files = sorted(folder_path.glob("*.jsonl"))

    if not jsonl_files:
        print(f"Warning: No JSONL files found in {folder_path}", file=sys.stderr)
        sys.exit(1)

    if verbose:
        print(f"Found {len(jsonl_files)} JSONL files")
        if exclude_system:
            print(
                "Filtering out system-generated messages (interruptions, bash, slash commands)"
            )

    all_messages = []
    for jsonl_file in jsonl_files:
        messages = extract_user_messages(jsonl_file, exclude_system=exclude_system)
        all_messages.extend(messages)
        if verbose and messages:
            print(f"  {jsonl_file.name}: {len(messages)} user messages")

    if verbose:
        filter_msg = " (filtered)" if exclude_system else ""
        print(f"\nExtracted {len(all_messages)} user messages{filter_msg}")

        unique_sessions = len(
            set(m["session_id"] for m in all_messages if m["session_id"])
        )
        print(f"  Unique sessions: {unique_sessions}")

        if all_messages:
            avg_length = sum(len(m["message"]) for m in all_messages) / len(
                all_messages
            )
            print(f"  Average message length: {avg_length:.1f} characters")

    return all_messages
